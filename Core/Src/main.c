// ELEC2645 Pong Game Demo
// =======================
// A classic Pong game demonstrating object-oriented game architecture with proper game loop.
// 
// KEY CONCEPTS:
// - Game objects (Ball, Paddle) encapsulate their own data and behavior
// - AABB (Axis-Aligned Bounding Box) collision detection for simple, fast collision checking
// - Update/Render separation: game logic updates happen separately from drawing
// - Game loop pattern: HANDLE INPUT → UPDATE OBJECTS → RENDER (full clear/redraw each frame)
//
// Controls:
// - Joystick UP/DOWN: Move paddle up and down
// - Objective: Hit ball with paddle to gain points
//
// Architecture:
// - PongEngine: Main game engine managing Ball, Paddle, and collisions
// - Ball: Object-oriented ball with position, velocity, and rendering
// - Paddle: Object-oriented paddle with input handling and collision
// - Utils: Collision detection (AABB) and shared types


// STM32 HAL headers (auto-generated by STM32CubeMX)
#include "main.h"
#include "tim.h"       // Timer 2 for PWM buzzer control
#include "usart.h"     // For serial output
#include "gpio.h"      // GPIO control
#include "adc.h"       // ADC for joystick input
#include "rng.h"       // RNG for randomized ball reset

// AUTO-GENERATED STM32 FUNCTION PROTOTYPES - DO NOT EDIT
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);

// Buzzer library
#include "Buzzer.h" // For buzzer control using TIM2
#include "PWM.h"    // For PWM control of the LED - not used in this demo but included for completeness and future expansion
#include "LCD.h"  // For LCD demonstration 
#include "Joystick.h" // include the Joystick driver functions
#include "PongEngine.h" // Main pong game engine
#include "Utils.h" // Common utility types and functions (Position2D, AABB, etc.)

#include <stdint.h>
#include <stdio.h>
#include <math.h>

// ===== BUZZER CONFIGURATION =====
// Configure buzzer to use TIM2 Channel 3 (current hardware setup)
Buzzer_cfg_t buzzer_cfg = {
    .htim = &htim2,
    .channel = TIM_CHANNEL_3,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 20,
    .max_freq_hz = 20000,
    .setup_done = 0
};

// ===== LCD CONFIGURATION =====
ST7789V2_cfg_t cfg0 = {
    .setup_done = 0,
    .spi = SPI2,
    .RST = {.port = GPIOB, .pin = GPIO_PIN_2},
    .BL = {.port = GPIOB, .pin = GPIO_PIN_1},
    .DC = {.port = GPIOB, .pin = GPIO_PIN_11},
    .CS = {.port = GPIOB, .pin = GPIO_PIN_12},
    .MOSI = {.port = GPIOB, .pin = GPIO_PIN_15},
    .SCLK = {.port = GPIOB, .pin = GPIO_PIN_13},
    .dma = {.instance = DMA1, .channel = DMA1_Channel5}
};

// ===== JOYSTICK CONFIGURATION =====
Joystick_cfg_t joystick_cfg = {
    .adc = &hadc1,
    .x_channel = ADC_CHANNEL_1, //A5 on Nucleo board
    .y_channel = ADC_CHANNEL_2, //A4 on Nucleo board
    .sampling_time = ADC_SAMPLETIME_47CYCLES_5,
    .center_x = JOYSTICK_DEFAULT_CENTER_X,
    .center_y = JOYSTICK_DEFAULT_CENTER_Y,
    .deadzone = JOYSTICK_DEADZONE,
    .setup_done = 0
};

// Joystick data structure to hold readings
Joystick_t joystick_data;

// ===== PWM CONFIGURATION =====
// Configure PWM to use TIM4 Channel 1 (current hardware setup)
PWM_cfg_t pwm_cfg = {
    .htim = &htim4,
    .channel = TIM_CHANNEL_1,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 10,
    .max_freq_hz = 50000,
    .setup_done = 0
};

// ===== FSM STATE DEFINITIONS =====
// For this Pong demo, we will not use a complex FSM with multiple states like the character demo.
// Instead, we will have a single "game running" state and a "game over" state. 
// The main game loop will run while the game is active, and when the player loses all lives, 
// it will transition to the game over state which displays the final score.

// ===== UTILITY FUNCTIONS =====

// Other utility functions (e.g. for collision detection) are defined in Utils.h

/**
 * @brief Redirect printf to UART for debugging
 */
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

// ===== PONG GAME GLOBAL VARIABLES =====
// Global pong game engine
PongEngine_t pong_engine;

// Game state flag
volatile uint8_t game_over = 0;

// Frame timing
// For a smooth game experience, we want to run the game loop at a consistent frame rate (e.g. 60 FPS).
// In this game we are not doing many calculations, so we can afford to do a full clear and redraw each frame for simplicity.
#define FPS 60
#define FRAME_TIME_MS (1000 / FPS)

// ===== NO EXTERNAL INPUT HANDLING NEEDED =====
// For simplicity, Pong only uses the joystick which is read synchronously
// (no interrupt-based input needed like the character demo had for buttons)

// ===== FUNCTION PROTOTYPES =====
void update_pong(UserInput input);
void render_pong(void);

// ===== Main Function =====

/**
  * @brief  The application entry point - Pong Game Demo
  * @retval int
  */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();
    PeriphCommonClock_Config();

    /* Initialize peripherals */
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();  // Initialize ADC for joystick
    MX_RNG_Init();   // Initialize RNG for ball reset
    
    // Initialize LCD first (this sets up GPIOB pins)
    LCD_init(&cfg0);

    // Initialize buzzer timer
    MX_TIM2_Init();
    buzzer_init(&buzzer_cfg);

    // Initialize TIM4 AFTER LCD to avoid GPIO conflict on PB6
    MX_TIM4_Init();
  
    // Initialize Joystick
    Joystick_Init(&joystick_cfg);
    
    // Initialize Pong Game Engine
    // PongEngine_Init(engine, paddle_x, paddle_y, paddle_width, paddle_height, ball_size, ball_speed)
    PongEngine_Init(&pong_engine, 
                    10,     // paddle at left side
                    100,    // roughly center Y
                    4,      // paddle width (4 pixels)
                    40,     // paddle height (40 pixels)
                    6,      // ball size (6 pixels - adjust for difficulty)
                    8.0f);  // ball speed (8 pixels/frame - adjust for difficulty)
    
    // Clear screen
    LCD_Fill_Buffer(0);
    LCD_Refresh(&cfg0);

    // Startup animation
    LCD_printString("PONG",  70, 50, 1, 4);
    LCD_Refresh(&cfg0);
    HAL_Delay(1000);
    
    // Display instructions
    LCD_Fill_Buffer(0);
    LCD_printString("Use Joystick", 50, 30, 1, 2);
    LCD_printString("UP/DOWN", 80, 60, 1, 2);
    LCD_printString("to Move", 80, 85, 1, 2);
    LCD_printString("Paddle!", 75, 110, 1, 2);
    LCD_Refresh(&cfg0);
    HAL_Delay(2000);

    // Initialize PWM for LED control - not used in this demo but included for completeness and future expansion
    PWM_Init(&pwm_cfg);
    PWM_SetFreq(&pwm_cfg, 1000);
    PWM_SetDuty(&pwm_cfg, 0);
    
    // Ensure LD2 on PA5 starts OFF
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);

    printf("Pong Game Engine initialized.\n");

    uint32_t last_tick = HAL_GetTick();

    while (!game_over)
    {
      uint32_t now = HAL_GetTick();
      if ((now - last_tick) < FRAME_TIME_MS) {
        continue; // this means skip this whole loop iteration and start at the top of the while loop again
      }
      last_tick = now;

      // ===== PONG GAME LOOP =====
      // Classic game loop pattern: INPUT -> UPDATE -> RENDER
        
      // Step 1: READ INPUT
      Joystick_Read(&joystick_cfg, &joystick_data);
        
      // Get UserInput structure from joystick data
      UserInput input = Joystick_GetInput(&joystick_data);
        
      // Step 2: UPDATE GAME STATE
      update_pong(input);
        
      // Step 3: RENDER TO SCREEN (full clear and redraw)
      render_pong();
    }
    
    int16_t line_offset = 0;
    // Game over display
    while (1) {
        
        LCD_Fill_Buffer(0);
        LCD_printString("Game Over!", 20 , 0 +line_offset, 1, 3);
        char score_str[32];
        sprintf(score_str, "Score: %d", PongEngine_GetScore(&pong_engine));
        LCD_printString(score_str, 20 , 20 + line_offset, 1, 2);
        LCD_Refresh(&cfg0);
        HAL_Delay(500);
        line_offset += 10;
        if (line_offset > 220) {
            line_offset = 0;
        } 
    }
}

// ===== UPDATE & RENDER FUNCTIONS =====

/**
 * @brief Update pong game state
 * 
 * This function handles all game logic updates:
 * - Updates paddle position based on joystick input
 * - Updates ball position
 * - Checks for collisions (AABB)
 * - Decrements lives if ball leaves play area
 * 
 * Separated from rendering for cleaner code architecture.
 */
void update_pong(UserInput input) {
    // Update the game engine with input
    uint8_t lives = PongEngine_Update(&pong_engine, input);
    
    // Check for game over
    if (lives == 0) {
        printf("Game Over! Final Score: %d\n", PongEngine_GetScore(&pong_engine));
        game_over = 1;  // Exit game loop
    }
}

/**
 * @brief Render the pong game to the LCD screen
 * 
 * This function handles all rendering/drawing:
 * - Clears the screen buffer (full clear)
 * - Draws ball sprite
 * - Draws paddle sprite
 * - Draws debug information (lives, score)
 * - Refreshes LCD to display the frame
 * 
 * Separated from game logic for cleaner code architecture.
 * IMPORTANT: This does a FULL clear and redraw every frame for simplicity.
 */
void render_pong(void) {
    // Step 1: Clear screen buffer (full clear for simple rendering)
    LCD_Fill_Buffer(0);
    
    // Step 2: Draw all game objects
    PongEngine_Draw(&pong_engine);
    
    // Step 3: Draw debug info (lives and score)
    char info_str[32];
    
    // Display lives in top-left
    sprintf(info_str, "Lives: %d", PongEngine_GetLives(&pong_engine));
    LCD_printString(info_str, 10, 10, 1, 2);
    
    // Display score in top-right
    sprintf(info_str, "Score: %d", PongEngine_GetScore(&pong_engine));
    LCD_printString(info_str, 130, 10, 1, 2);
    
    // Step 4: Refresh LCD to display this frame
    LCD_Refresh(&cfg0);
}

// ===== Interrupt Callback =====
// Note: Pong game only uses joystick input which is handled synchronously in the main loop.
// If button input is needed in the future, an interrupt handler can be added here.







// ==== AUTO-GENERATED STM32 FUNCTIONS ====
// DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING! 


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSI;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}



/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
